\chapter{Практика}\label{ch:ch3}

\section{Мобильный автономный робот}
Для решения задачи данной работы необходимо было проводить <<живые>> тестирования работы алгоритмов. Такая необходимость обусловлена прежде всего тем, что помимо существующей задачи данной ВКР стояла задача в создании робота для распознавания объектов. По этой причине было принято решение делать алгоритмы на реальном роботе\footnote{Задание данной ВКР можно было бы сделать и в любом симуляторе или игровом движке. Однако решение делать всё в реальной жизни сильно усложнило данную задачу.} с пребыванием данного робота во вполне реальных условиях.

\subsection{Подбор шасси}
Как было сказано в \fixme{первой} главе данной работы, существует большое количество различных шасси, на которых можно располагать различное оборудование. Наш выбор остановился на гусеничном шасси, которое \fixme{изображено на Рисунке }.

Данное шасси за счёт своих размеров является очень мобильным средством передвижения робота и может проникнуть в относительно узкие для роботов пространства и без проблем оттуда выбраться, не повредившись. Для оборудования на данном шасси место тоже нашлось: для этого было принято решение заказать металлическую пластину, которая играла роль второго этажа. \fixme{поставить рисунок?}

\subsection{Движение шасси}

К сожалению, по неизвестной причине к данному шасси не пришёл комплектный контроллер движения, который бы принимал команды от компьютера и заставлял двигаться установленные гусеницы. По этой причине пришлось немного изучить ещё одну предметную область, которая не изучалась в течении университетского курса - электротехнику. 

\subsubsection{Требования к контроллеру движений}

Компьютер, который будет в последствии установлен на робота будет управлять роботом посредством бинарных сигналов с напряжением 3.3В через порт GPIO, где 0 (или по-другому нет напряжения) - это движение не требуется и 1 (когда есть напряжение +3.3В), когда движение требуется.

Контроллер должен, также, уметь по отдельности управлять двумя гусеницами, заставлять их ездить вперёд и назад. Это основные требования. Из дополнительных требований можно выделить умение каким-то образом регулировать скорость движения. Общая структура желаемой модели контроллера \fixme{изображена на Рисунке }. 

\subsubsection{Схема будущего контроллера}

	\fixme{Здесь теоретическое объяснение как работает контроллер}

\subsubsection{Производство контроллера}

В качестве основы для контроллера было принято решение взять текстолитовую пластину c медным покрытием, \fixme{изображённую на рисунке }.
	
Далее на нём при помощи перманентного маркера были нанесены дорожки, а места вставки деталей были просверлены советской стоматологической бур-машинкой. Далее всё это прошло ванну хлорида железа. Процесс и результаты работы \fixme{изображены на Рисунке }.
	
\subsubsection{Результаты работы}

Таким образом был получен полноценный контроллер, который умеет управлять роботом медленной и быстрой скоростями. Однако, не обошлось без недостатков и трудностей. Главной трудностью стал неудачный способ стравливания дорожек на плате, поэтому пришлось дополнительно при помощи олова проводить дорожки и искать потенциально уязвивмые места.

После большой ручной работы плату удалось запустить, но появилась другая проблема. И эта проблема заключалась в том, что сопротивление двигателей робота немного отличалось друг от друга, также как и сопротивление резисторов, установленных на плату. Данное отличие было ничтожным, но этого вполне хватало, чтобы робот начинал ездить не очень ровно и его всё время приходилось дополнительно корректировать.

\subsubsection{Вторая версия контроллера}

Необходимость во второй версии контроллера возникла в первую очередь из-за того, что медленная скорость на роботе работала слишком медленно, а быстрая слишком быстро. Ездить в магазин и вручную подбирать резисторы, каждый раз перепаивая плату совсем не хотелось, а каждый резистор в местных магазинах обходится в неприятную для таких расходных деталей сумму. 

Переделка первой версии платы обошлась бы слишком дорого в плане времени, да и к тому же не хотелось портить, то, что и так уже работает. Поэтому вторая версия платы была собрана по той же схеме, что и первая, но с несколькими важными отличиями. Из стабилизаторов остался только стабилизатор на 9В, а обычные резисторы были заменены на соответствующие подстроечные резисторы. Таким образом должна была появилась возможность регулировать движение в зависимости от того, в каком положении будет установлен сам резистор. Получившаяся плата \fixme{изображена на Рисунке }.

\section{Визуальный анализ пространства}
Для анализа окружающего пространства существует довольно большое количество различных датчиков и прочего оборудования. Но закупать сразу всё не выгодно экономически, затратно в плане места размещения на роботе и расточительно в плане потребления электроэнергии этими самыми датчиками. Также для обработки всех этих сигналов нужны соответствующие вычислительные мощности. 

Таким образом робот должен иметь совсем небольшое количество сенсоров и при этом не быть <<слепым>>. Исходя из этих соображений, было решено установить на робота два основных сенсора: лазерный сканер YDLIDAR X4 и CSI камеру Sony IMX217. Первый поможет видеть препятствия вокруг робота, второй поможет видеть объекты, размещённые перед роботом. 

Схема размещения сенсоров \fixme{размещена на Рисунке }.

\section{Формирование поведенческой стратегии робота}

Основная задача робота - ездить и искать целевые объекты делится на две подзадачи.

\subsection{Езда}

Этот режим поездки можно также назвать режимом исследователя. В идеальном случае, робот в начале работы алгоритма движения должен объездить всё доступное ему пространство, составить карту окружающей местности, параллельно при этом запоминая увиденные им объекты и их примерное местоположение\footnote{его нужно вычислять из расчётов того, куда смотрит в данный момент робот, угла прямоугольника на изображении, на котором объект был обнаружен}, а затем после полного сканирования объехать всю территорию и убедиться в том, что целевые объекты действительно были найдены на этих местах. И это должно стать конечной целью робота. Однако, для упрощения данной задачи будет использоваться другой куда более простой алгоритм. 

Режим исследователя будет подразумевать под собой то, что робот будет просто ехать вперёд, параллельно разыскивая целевые объекты и объезжая препятствия. 

\subsubsection{Объезд препятствий}

Робот должен уметь объезжать хотя-бы самые простейшие препятствия, по типу стен, диванов или прочих перегородок. В идеале, он должен уметь справляться и с тонкими препятствиями по типу ножек стула и мягкие поверхности.

Алгоритм объезда препятствий, представленный на данном роботе сводится к схеме, \fixme{изображённой на Рисунке }.

Подсчёт того, где свободнее: слева или справа идёт из соображений того, где находится больше препятствий. Как это считается? Условно робот поделён на несколько направлений. В данном случае он подразделён на <<перед>>, <<лево>>, <<право>> и <<зад>>. Обозначим значения, которые высчитываются на этих направлениях, как $f, l, r$ и $b$ соответственно. 

Лидар выдаёт данные в формате массива значений float: обозначим его как числовой ряд $a$. В этом числовом ряду находятся числа, обозначающие расстояние до точки об которое отразился лазер. Чем больше число, тем дальше находится объект об который отразился лазер. Если лазерный сканер не нашёл в этом месте отражения, то он возвращает значение -1. Фактически, данный массив является аналогом полярных координат, где позиция значения в массиве - это угол, а само значение является расстоянием. Всего этих чисел 720, из чего можно сделать вывод, что цена деления лидара это полградуса. 

Таким образом каждый поворот лидара вычисляются 4 переменные\footnote{Важное замечание: значения -1, когда лазерный сканер не нашёл отражения заменяются на значение 1 для того чтобы значения переменных прибавлялись, а не уменьшались.}:

\[
\begin{array}{c}
l = \frac{\displaystyle\sum_{i=90}^{270} a_i}{180} \quad
b = \frac{\displaystyle\sum_{i=270}^{450} a_i}{180}\quad
r = \frac{\displaystyle\sum_{i=450}^{630} a_i}{180} \quad
f = \frac{\displaystyle\sum_{i=630}^{720} a_i + \sum_{i=0}^{90} a_i}{180}
\end{array}
\]

После вычисления этих средних арифметических значений по каждой из сторон проверяются значения массива $a_i$, где $630 < i < 720$ и $0 < i < 90$ (передняя сторона робота) и если среди этих чисел находится хоть одно удовлетворяющее условию $0 < a_i < 0,3$, то считается в данный момент перед роботом находится какое-то препятствие.

Если это так, то далее сравниваются значения ранее высчитанных переменных $l$ и $r$. Если значение $l > r$, то робот поедет налево, так как слева нашлось меньше препятствий, чем справа. Иначе, роботу следует ехать направо. Однако представленного выше алгоритма ещё недостаточно чтобы объезжать часто встречаемые препятствия. 

\subsubsection{Обнаружение застревания}

Робот может попасть в ситуацию, когда впереди внезапно образовалась преграда, невидимая для лазерного сканера (например, очень низкая преграда). Для обнаружения застревания при столкновении с такими преградами необходимо как-то понять, что робот перестал двигаться. 

Одним из способов понять и распознать застревание может стать анализ облака точек, которые выдаёт LIDAR. Если вектор движения большинства точек на плоскости облака стал достаточно мал, то можно сделать вывод о том, что робот либо плохо двигается, либо вообще застрял. 

В данный проект была встроена система Google Cartographer, которая по облаку точек может строить окружающую карту местности, а также определять местоположение робота на ней. Информацию о местоположении можно использовать как раз в целях определения застревания. Если в течении секунды координаты робота менялись недостаточно сильно, то значит робот застрял.

Для выезда из застревания используется простой алгоритм, который состоит из 3 шагов:

\begin{enumerate}
\item Ехать назад 2 секунды;
\item Выбрать сторону, в которую будет совершён поворот по значениям выше упомянутых переменных $l$ и $r$;
\item Ехать дальше.
\end{enumerate}

Как показала практика, этот алгоритм работает достаточно эффективно для того чтобы не застревать в большинстве ситуаций.

\subsection{Поиск целевого объекта}

Данный режим предполагается включать только в случае, если на видеосигнале, получаемом от CSI камеры был распознан целевой объект. В этом случае робот останавливается и поворачивается в ту сторону, где расположен центр предполагаемого целевого объекта. Далее робот начинает ехать вперёд и по мере необходимости продолжает центрировать шасси до тех пор пока не подъедет к объекту. Далее робот останавливается, конечная цель робота выполнена: целевой объект найден.

Определение того, что робот подъехал к объекту происходит по размеру прямоугольника, на котором обозначен целевой объект. Если прямоугольник уже достиг краёв кадра видеосигнала, значит робот приблизился к объекту максимально близко. Подъезд вплотную к объекту является не самой лучшей идеей, так как целевым объектом может быть стеклянная бутылка, которую можно просто сбить и разбить. 

\section{Подробнее о программной части робота}
На одноплатный компьютер Nvidia Jetson Nano была установлена операционная система Ubuntu LTS 18.04 со специальным от Nvidia программным обеспечением JetPack 4.3, которое предоставляет удобные инструменты для вычислений в области искусственного интеллекта при помощи встроенного в Jetson NANO видеочипа и ядер CUDA. Также на компьютер была установлен фреймворк для программирования роботов ROS, аббревиатура которого расшифровывается как <<Операционная система для роботов>>.

%Ссылка на преддипломку
\subsection{ROS}
ROS предоставляет удобные и мощные функции, помогающие разработчикам в таких задачах, как передача сообщений различного типа, распределение вычислений между компьютерами, повторное использование кода и реализация современных алгоритмов для роботизированных приложений. В общем случае, ROS представляет собой инструмент, позволяющий связывать несколько независимых программных модулей при помощи сервисов и узлов, которые могут передавать друг другу сообщения в различном формате.

Большими преимуществами использования данного фреймворка является возможность передачи сообщений по локальной сети и обширная библиотека уже реализованного ПО, которое можно без относительно больших затрат по времени интегрировать в свой собственный проект. На момент написания данной ВКР глобальный репозиторий ROS Index насчитывает 2120 подключенных к нему сторонних репозиторием и 5827 пакетов.

\subsection{Концепции ROS}
Ниже приведён список концепций рассматриваемого фреймворка:
\begin{itemize}
\item {\textbf{Узел} - это процесс, выполняющий вычисления. Каждый узел написание с использованием клиентских библиотек ROS. Используя методы связи, узлы могут общаться друг с другом заранее определённым форматом сообщений и обмениваться данными. Для этого создаются узлы-подписчики, и узлы-публикаторы.}
\item {\textbf{Мастер} - обеспечивает регистрацию и работоспособность запущенных узлов.}
\item {\textbf{Сообщение} - простая структура данных, содержащая типизированное поле, которое может содержать целый набор данных, отправляемых на другой узел. Помимо стандартных типов сообщений\footnote{Такие как целые, с плавающей точкой, логические, строковые...} возможна отправка заранее обозначенных собственных типов сообщений.}
\item {\textbf{Тема} - именованная шина данных, используемая узлами для отправки сообщений. Публикующий и подписанный узел не знают о существовании друга друга. Благодаря тому что каждая тема имеет уникальное имя, любой узел может получить доступ к данной теме и отправляет через неё данные, при условии соблюдении заранее оговорённых передаваемых типов, данной темой.}
\item {\textbf{Сервисы} - реализация удалённого вызова процедур\footnote{RPC} в ROS. В некоторых случаях модель связи публикации и подписки может не подходить. В этих случаях и применяют взаимодействия в виде сервисов (схема запрос/ответ), при котором один узел может запросить выполнение процедуры для другого узла, ожидая какого-то обязательного ответа\footnote{В случае использования схемы с подписчиками и публикаторами доставка сообщений и ответ не гарантируются}.}
\end{itemize}

\subsection{Узлы, используемые на роботе}
В рамках работы над данной ВКР были реализованы следующие узлы и сервисы:
\begin{itemize}
\item Сервис, управляющий сигналами на разъёме GPIO; 
\item Узел записи видео с видеокамеры;
\item Узел распознавания объектов;
\item Узел, управляющий движением робота и формирующий поведенческую стратегию робота.
\end{itemize}

Также в роботе используются следующие сторонние узлы:
\begin{itemize}
\item Узел передачи изображения с CSI видеокамеры;
\item Google Cartographer;
\item Узел YDLIDAR.
\end{itemize}

Общую схему взаимодействия всех узлов можно увидеть \fixme{на Рисунке }.

\subsubsection{Узел видеокамеры}
Данный узел был заимствован из репозитория робота JetBot и он публикует изображения в формате сообщения, описанного стандартом ROS sensor\_msgs/Image (содержание сообщения можно \fixme{увидеть в Приложении }), получаемые из CSI камеры IMX217, подключенной к Nvidia Jetson NANO. Для получения такого видеосигнала используется библиотека GStreamer и встроенные в образ Linux драйвера на данный сенсор. Пример получаемого изображения \fixme{показан на Рисунке }. Таким образом на выходе данного узла получается топик по имени raw, содержащий изображения.

\subsubsection{Узел YDLIDAR}
Данный узел представляет собой драйвер для YDLIDAR X4 и занимается его непосредственным запуском, остановкой, а также публикацией облака точек, формируемых лазерным сканером. Формат сообщения определён стандартом ROS sensor\_msgs/LaserScan.  Содержимое данного сообщения можно посмотреть \fixme{в приложении }. Пример получаемого изображения, создающегося из облака точек можно увидеть на \fixme{Рисунке }. Таким образом на выходе данного узла получается топик с именем scan содержащий sensor\_msgs/LaserScan.

%ссылка https://google-cartographer-ros.readthedocs.io/en/latest/ros_api.html
\subsubsection{Google Cartographer}
Данный узел занимается обработкой узла scan, публикуемого узлом YDLIDAR. Основной задачей Google Cartographer является SLAM - то есть одновременная локализация и построение карты окружающей местности, для этого данной системе нужно выполнять очень много задач, а потому на выходе мы имеем сразу несколько топиков:
\begin{enumerate}
\item scan\_matched\_points: данный топик определяется стандартом sensor\_msgs/PointCloud2 (описание смотрите \fixme{в Приложении }) и представляет собой облако точек в том виде, в котором оно использовалось для сопоставления сканирования с подкартами, создающимися Google Cartographer. Это облако отфильтровано и спроецировано так как это описывает конфигурационный файл Lua. Изображение, получаемое из данного облака точек можно \fixme{увидеть на Рисунке };
\item submap\_list: этот топик является список всех вложенных карт, включая позу и номер последней версии каждой вложенной карты, по всем пройденным траекториям робота. Формат сообщений описан собственным стандартом cartographer\_ros\_msgs/SubmapList, его содержимое увидеть \fixme{в Приложении }. Пример изображения, генерируемого при помощи submap\_list можно \fixme{увидеть на Рисунке };
\item map: этот топик появляется только если указать это в конфигурационном файле и представляет собой цельную карту, которую сгенерировал Google Cartographer в виде двумерной матрицы. Формат этого топика определён сообщением стандарта ROS nav\_msgs/OccupancyGrid, его содержимое увидеть \fixme{в Приложении}.
\end{enumerate}

\subsubsection{Сервис GPIO}
Данный сервис был создан с нуля на языке C++ в целях управления контроллером электродвигателей робота при помощи установленного на Nvidia Jetson NANO разъёма стандарта GPIO, схему которого можно увидеть \fixme{на Рисунке }.

На вход сервиса приходит команда в виде числа в формате uint8. Действие каждой команды закреплено в заголовочном файле commands.hpp в пространстве имён MoveCommands. Всего доступно 20 различных команд, которые являются комбинацией двух характеристик: гусеница и скорость. Дополнительно имеются команды на движение вперёд и назад\footnote{Данные команды для движения задействуют одновременно все гусеницы робота.} с возможностью выбора скорости. Всего гусениц на роботе установлено две: левая и правая. А скоростей доступно 4 штуки:

\begin{enumerate}
\item Остановка (нет скорости);
\item Медленная;
\item Средняя;
\item Быстрая.
\end{enumerate}

На выходе сервис возвращает своим клиента переменную в формате boolean, значение true которой говорит об успешности подачи или снятия напряжения 3.3В на ножки разъёма GPIO или false при возникновении какой-либо ошибки. Используемые ножки для контроля двигателями ножки можно увидеть на схеме, \fixme{изображённой на Рисунке }.

Управление пинами GPIO происходит при помощи выполнения следующих команд в оболочке bash, вызываемых при помощи стандартной функции system("команда"):
\begin{enumerate}
\item echo <<номер пина>> > /sys/class/gpio/export;
\item echo <<номер пина>> > /sys/class/gpio/unexport;
\item echo <<in или out>> > /sys/class/gpio/gpio<<номер пина>>/direction;
\item echo <<значение 1 или 0>> > /sys/class/gpio/gpio<<номер пина>>/value.
\end{enumerate} 

Первая команда служит для того активировать данную ножку на разъёме и разрешить управление над ней. Вторая команда, соответственно, выключает данную ножку. Третья команда выполняется для назначения <<направления>> данной ножки. Она может быть как входной, то есть ждать какого-то управляющего сигнала, так и выходной, то есть сама подавать напряжение +3.3В. Последняя команда управляет тем значением, которое будет на ножке.

Также, дополнительно были сделаны тестовые клиенты к данному сервису. Первый позволяет при помощи нажатий клавиш WASD управлять направлением движения робота в ручном режиме. Второй тестовый клиент также представляет интерфейс для ручного управления роботом, но уже в полном функционале, то есть нажатие определённой клавиши на клавиатуре вызывает определённую команду GPIO сервиса.

\subsubsection{Узел записи видео}
Данный узел был создан в целях сборки данных для обучения нейронной сети, которая отвечает за распознавание объектов и во время работы робота никак не используется. Узел записи видео подписывается на топик raw, в который узел камеры публикует кадры, получаемые из подключенной CSI видеокамеры. Полученные кадры подгоняются под размер 640x480, преобразуются в формат bgr8, а затем передаются открытой библиотеке компьютерного зрения OpenCV\footnote{Конкретно, в данном случае используется C++ класс cv::VideoWriter}, которая настроена так чтобы записывать видеофайлы с частотой кадров 20 кадров в секунду каждые 1000 полученных кадров на подключенный к Jetson NANO по интерфейсу USB 3.0 внешний жёсткий диск в кодировке DIVX и формате avi. Имя каждого файла уникально и состоит из базового имени (в данном случае mike-video-) и текущей даты с временем в формате <<день-месяц-год-час-минута-секунда>>. Это позволяет не перезаписывать каждый раз одно и то же видео, а иметь сразу много кусков и не переживать за конфликт имён.

\subsubsection{Узел распознавания объектов}
Узел распознавания объектов написан на языке Python версии 3. На входе он подписывается на топик видеокамеры raw, а на выходе предоставляет сообщения собственного стандарта inference/Bboxes. Bboxes состоит из одного элемента - массива сообщений Bbox, который представляет собой массив так называемых bounding box. Bounding box - это по сути прямоугольник, генерируемый нейронной сетью, который указывает на распознанные объекты на входном видеоизображении. Распознанных объектов в кадре может быть несколько, а значит и этих прямоугольников за один кадр может сгенерироваться несколько, поэтому важно передавать именно массив bounding box. В определённом в данном узле собственном стандарте сообщения inference/Bbox у каждого bounding box'а имеются следующие значения:

\begin{enumerate}
\item x\_min - первая координата прямоугольника по оси $x$ в формате float32;
\item y\_min - первая координата прямоугольника по оси $y$ в формате float32;
\item x\_max - вторая координата прямоугольника по оси $x$ в формате float32;
\item y\_max - вторая координата прямоугольника по оси $y$ в формате float32;
\item score - вероятность в формате float32 того, что распознанный объект распознан верно;
\item label в строковом формате string - название распознанного объекта \footnote{по нему можно понять какого вида объект был обнаружен и понять является ли он целевым}.
\end{enumerate}

Для распознавания объектов используется нейронная сеть, запускаемая на видеоядре компьютера Nvidia Jetson NANO, основанная на \fixme{MobileNetSSDv2, обученная на собранном с видеокамеры робота датасете, а также прошедшая оптимизация при помощи ПО от компании Nvidia - TensorRT}. Данная нейронная сеть создавалась не в рамках работы над данной ВКР, поэтому подробности её создания не будут освещены в тексте данной работы. Из распознаваемых данной нейронной сетью объектов можно выделить:

\begin{itemize}
\item Прозрачная бутылка;
\item Кухонный нож с белой ручкой;
\item Пластиковый контейнер лапши быстрого приготовления;
\item Глубокая фарфоровая тарелка;
\item Фонарик с металлическим корпусом;
\item Синяя шариковая авторучка.

\end{itemize} 

\subsubsection{Узел движения}
Данный узел является самым главным узлом в данной работе. Его задача принимать решения о том, куда поедет робот на основании тех данных, которые приходят из нейронной сети, лазерного сканера YDLIDAR, и Google Cartographer.

Узел движения подписывается на 2 топика: /scan - который содержит облако точек, выдаваемых лидаром, и /bboxes - топик, в который попадают bounding box из нейросети. Также, узел включает в себя слушателя изменений местоположения робота по имени <<base\_link>>. Именно по этому имени можно получить текущее местоположение робота на карте, создающейся Google Cartographer. Помимо этого узел является клиентом сервиса управления двигателями для того чтобы иметь возможность непосредственно отдавать команды для различных манёвров робота.

\paragraph{Обработка облака точек.} Приходящее в узел облако точек из 720 элементов, как и было описано в \fixme{Главе 2} делится на 4 части, по каждой из которой считается среднее арифметическое число: перед $f$, зад $b$, лево $l$ и право $r$. В первую очередь анализируется передняя часть. Если на ней было обнаружено хоть одно число больше $0$ и менее $0,3$, то считается, что перед роботом есть препятствие и нужно поворачивать. Поворот в нужную сторону длится 1 секунду, затем алгоритм повторяется.

\paragraph{Обработка застреваний}
Для обработки застреваний устанавливается слушатель так называемого transform. Узел слушает два transform'а: <<base\_link>> и <<map>>, которые генерируются Google Cartographer. В первом содержится информация об отклонении местоположения и вектора поворота от второго transform. Без второго transform нельзя было бы понять местоположение робота, так как не было бы <<базового>> местоположения (объекта transform) с которым и происходит сравнение. Каждый раз программа запоминает последнее местоположение робота и момент времени в котором данное местоположение было запомнено. Как только проходит одна секунда, проверяется насколько сильно робот изменил местоположение. Если робот не <<застрял>>, то запоминается новое время и местоположение робота. Если местоположение изменилось недостаточно сильно ($dx < 0,3$, $dy < 0,3$ и отклонение вектора поворота $dr < 3$ градуса), то происходит перехват управления: робот останавливается, движется назад в течении секунды, затем ищется в какую сторону повернуть по высчитанным ранее средним арифметическим числам. Робот поворачивает в течении секунды, затем движение продолжается как обычно. 

\paragraph{Следование за целевым объектом.} При появлении какого-либо распознанного объекта в кадре, нейронная сеть посылает в топик /bboxes сообщение с координатами прямоугольника, в рамках которого и находится распознанный объект. Если распознанных объектов больше чем 1, то для дальнейшего анализа выбирается тот, у кого более высокая вероятность правильного совпадения имени распознанного объекта с действительностью. Это делается для того чтобы отфильтровать те различные мелкие фрагменты объекта, которые в виду неточности работы нейронной сети появляются на распознанном объекте.

Следующим шагом проверяется название объекта и если оно есть в списке целевых объектов, то фактически происходит перехват управления. Робот останавливается и центр прямоугольника распознанного объекта выравнивается в кадре и становится стабильнее. После этого шасси робота доворачивается таким образом, чтобы центр прямоугольника, в котором находится целевой объект оказался в середине (с небольшой допустимой погрешностью) кадра видеокамеры\footnote{Для этих целей в исходном коде программы заранее записано разрешение видеокадра, с которым оперирует нейронная сеть.}. После этого робот начинает движение вперёд ровно до тех пор, пока какой-либо из краёв прямоугольника не достигнет края кадра. Если роботу удалось достигнуть данной точки, то движение останавливается, так как считается, что робот выполнил свою задачу, найдя целевой объект на местности. Схема данного алгоритма \fixme{представлена на Рисунке }.

\section{Таблица обыкновенная}\label{sec:ch3/sect1}

Так размещается таблица:

\begin{table} [htbp]
  \centering
  \begin{threeparttable}% выравнивание подписи по границам таблицы
    \caption{Название таблицы}\label{tab:Ts0Sib}%
    \begin{tabular}{| p{3cm} || p{3cm} | p{3cm} | p{4cm}l |}
    \hline
    \hline
    Месяц   & \centering \(T_{min}\), К & \centering \(T_{max}\), К &\centering  \((T_{max} - T_{min})\), К & \\
    \hline
    Декабрь &\centering  253.575   &\centering  257.778    &\centering      4.203  &   \\
    Январь  &\centering  262.431   &\centering  263.214    &\centering      0.783  &   \\
    Февраль &\centering  261.184   &\centering  260.381    &\centering     \(-\)0.803  &   \\
    \hline
    \hline
    \end{tabular}
  \end{threeparttable}
\end{table}

\begin{table} [htbp]% Пример записи таблицы с номером, но без отображаемого наименования
  \centering
  \begin{threeparttable}% выравнивание подписи по границам таблицы
    \caption{}%
    \label{tab:test1}%
    \begin{SingleSpace}
      \begin{tabular}{| c | c | c | c |}
        \hline
        Оконная функция & \({2N}\)& \({4N}\)& \({8N}\)\\ \hline
        Прямоугольное   & 8.72  & 8.77  & 8.77  \\ \hline
        Ханна           & 7.96  & 7.93  & 7.93  \\ \hline
        Хэмминга        & 8.72  & 8.77  & 8.77  \\ \hline
        Блэкмана        & 8.72  & 8.77  & 8.77  \\ \hline
      \end{tabular}%
    \end{SingleSpace}
  \end{threeparttable}
\end{table}

Таблица~\ref{tab:test2} "--- пример таблицы, оформленной в~классическом книжном
варианте или~очень близко к~нему. \mbox{ГОСТу} по~сути не~противоречит. Можно
ещё~улучшить представление, с~помощью пакета \verb|siunitx| или~подобного.

\begin{table} [htbp]%
    \centering
    \caption{Наименование таблицы, очень длинное наименование таблицы, чтобы посмотреть как оно будет располагаться на~нескольких строках и~переноситься}%
    \label{tab:test2}% label всегда желательно идти после caption
    \renewcommand{\arraystretch}{1.5}%% Увеличение расстояния между рядами, для улучшения восприятия.
    \begin{SingleSpace}
        \begin{tabular}{@{}@{\extracolsep{20pt}}llll@{}} %Вертикальные полосы не используются принципиально, как и лишние горизонтальные (допускается по ГОСТ 2.105 пункт 4.4.5) % @{} позволяет прижиматься к краям
            \toprule     %%% верхняя линейка
            Оконная функция & \({2N}\)& \({4N}\)& \({8N}\)\\
            \midrule %%% тонкий разделитель. Отделяет названия столбцов. Обязателен по ГОСТ 2.105 пункт 4.4.5
            Прямоугольное   & 8.72  & 8.77  & 8.77  \\
            Ханна           & 7.96  & 7.93  & 7.93  \\
            Хэмминга        & 8.72  & 8.77  & 8.77  \\
            Блэкмана        & 8.72  & 8.77  & 8.77  \\
            \bottomrule %%% нижняя линейка
        \end{tabular}%
    \end{SingleSpace}
\end{table}

\section{Таблица с многострочными ячейками и примечанием}

В таблице~\ref{tab:makecell} приведён пример использования команды
\verb+\multicolumn+ для объединения горизонтальных ячеек таблицы,
и команд пакета \textit{makecell} для добавления разрыва строки внутри ячеек.
При форматировании таблицы~\ref{tab:makecell} использован стиль подписей \verb+split+.
Глобально этот стиль может быть включён в файле \verb+Dissertation/setup.tex+ для диссертации и в
файле \verb+Synopsis/setup.tex+ для автореферата.
Однако такое оформление не соответствует ГОСТ.

\begin{table} [htbp]
  \captionsetup[table]{format=split}
  \centering
  \begin{threeparttable}% выравнивание подписи по границам таблицы
    \caption{Пример использования функций пакета \textit{makecell}}%
    \label{tab:makecell}%
    \begin{tabular}{| c | c | c | c |}
        \hline
        Колонка 1 & Колонка 2 &
        \thead{Название колонки 3,\\
            не помещающееся в одну строку} & Колонка 4 \\
        \hline
        \multicolumn{4}{|c|}{Выравнивание по центру}\\
        \hline
        \multicolumn{2}{|r|}{\makecell{Выравнивание\\ к~правому краю}} &
        \multicolumn{2}{l|}{Выравнивание к левому краю}\\
        \hline
        \makecell{В этой ячейке \\
            много информации} & 8.72 & 8.55 & 8.44\\
        \cline{3-4}
        А в этой мало         & 8.22 & \multicolumn{2}{c|}{5}\\
        \hline
    \end{tabular}%
  \end{threeparttable}
\end{table}

Таблицы~\ref{tab:test3} и~\ref{tab:test4} "--- пример реализации расположения
примечания в~соответствии с ГОСТ 2.105. Каждый вариант со своими достоинствами
и~недостатками. Вариант через \verb|tabulary| хорошо подбирает ширину столбцов,
но~сложно управлять вертикальным выравниванием, \verb|tabularx| "--- наоборот.
\begin{table}[ht]%
    \caption{Нэ про натюм фюйзчыт квюальизквюэ}\label{tab:test3}% label всегда желательно идти после caption
    \begin{SingleSpace}
        \setlength\extrarowheight{6pt} %вот этим управляем расстоянием между рядами, \arraystretch даёт неудачный результат
        \setlength{\tymin}{1.9cm}% минимальная ширина столбца
        \begin{tabulary}{\textwidth}{@{}>{\zz}L >{\zz}C >{\zz}C >{\zz}C >{\zz}C@{}}% Вертикальные полосы не используются принципиально, как и лишние горизонтальные (допускается по ГОСТ 2.105 пункт 4.4.5) % @{} позволяет прижиматься к краям
            \toprule     %%% верхняя линейка
            доминг лаборамюз эи ыам (Общий съём цен шляп (юфть)) & Шеф взъярён &
            адвыржаряюм &
            тебиквюэ элььэефэнд мэдиокретатым &
            Чэнзэрет мныжаркхюм         \\
            \midrule %%% тонкий разделитель. Отделяет названия столбцов. Обязателен по ГОСТ 2.105 пункт 4.4.5
            Эй, жлоб! Где туз? Прячь юных съёмщиц в~шкаф Плюш изъят. Бьём чуждый цен хвощ! &
            \({\approx}\) &
            \({\approx}\) &
            \({\approx}\) &
            \( + \) \\
            Эх, чужак! Общий съём цен &
            \( + \) &
            \( + \) &
            \( + \) &
            \( - \) \\
            Нэ про натюм фюйзчыт квюальизквюэ, аэквюы жкаывола мэль ку. Ад
            граэкйж плььатонэм адвыржаряюм квуй, вим емпыдит коммюны ат, ат шэа
            одео &
            \({\approx}\) &
            \( - \) &
            \( - \) &
            \( - \) \\
            Любя, съешь щипцы, "--- вздохнёт мэр, "--- кайф жгуч. &
            \( - \) &
            \( + \) &
            \( + \) &
            \({\approx}\) \\
            Нэ про натюм фюйзчыт квюальизквюэ, аэквюы жкаывола мэль ку. Ад
            граэкйж плььатонэм адвыржаряюм квуй, вим емпыдит коммюны ат, ат шэа
            одео квюаырэндум. Вёртюты ажжынтиор эффикеэнди эож нэ. &
            \( + \) &
            \( - \) &
            \({\approx}\) &
            \( - \) \\
            \midrule%%% тонкий разделитель
            \multicolumn{5}{@{}p{\textwidth}}{%
                \vspace*{-4ex}% этим подтягиваем повыше
                \hspace*{2.5em}% абзацный отступ - требование ГОСТ 2.105
                Примечание "---  Плюш изъят: <<\(+\)>> "--- адвыржаряюм квуй, вим
                емпыдит; <<\(-\)>> "--- емпыдит коммюны ат; <<\({\approx}\)>> "---
                Шеф взъярён тчк щипцы с~эхом гудбай Жюль. Эй, жлоб! Где туз?
                Прячь юных съёмщиц в~шкаф. Экс-граф?
            }
            \\
            \bottomrule %%% нижняя линейка
        \end{tabulary}%
    \end{SingleSpace}
\end{table}

Если таблица~\ref{tab:test3} не помещается на той же странице, всё
её~содержимое переносится на~следующую, ближайшую, а~этот текст идёт перед ней.
\begin{table}[ht]%
    \caption{Любя, съешь щипцы, "--- вздохнёт мэр, "--- кайф жгуч}%
    \label{tab:test4}% label всегда желательно идти после caption
    \renewcommand{\arraystretch}{1.6}%% Увеличение расстояния между рядами, для улучшения восприятия.
    \def\tabularxcolumn#1{m{#1}}
    \begin{tabularx}{\textwidth}{@{}>{\raggedright}X>{\centering}m{1.9cm} >{\centering}m{1.9cm} >{\centering}m{1.9cm} >{\centering\arraybackslash}m{1.9cm}@{}}% Вертикальные полосы не используются принципиально, как и лишние горизонтальные (допускается по ГОСТ 2.105 пункт 4.4.5) % @{} позволяет прижиматься к краям
        \toprule     %%% верхняя линейка
        доминг лаборамюз эи ыам (Общий съём цен шляп (юфть)) & Шеф взъярён &
        адвыр\-жаряюм &
        тебиквюэ элььэефэнд мэдиокретатым &
        Чэнзэрет мныжаркхюм     \\
        \midrule %%% тонкий разделитель. Отделяет названия столбцов. Обязателен по ГОСТ 2.105 пункт 4.4.5
        Эй, жлоб! Где туз? Прячь юных съёмщиц в~шкаф Плюш изъят.
        Бьём чуждый цен хвощ! &
        \({\approx}\) &
        \({\approx}\) &
        \({\approx}\) &
        \( + \) \\
        Эх, чужак! Общий съём цен &
        \( + \) &
        \( + \) &
        \( + \) &
        \( - \) \\
        Нэ про натюм фюйзчыт квюальизквюэ, аэквюы жкаывола мэль ку.
        Ад граэкйж плььатонэм адвыржаряюм квуй, вим емпыдит коммюны ат,
        ат шэа одео &
        \({\approx}\) &
        \( - \) &
        \( - \) &
        \( - \) \\
        Любя, съешь щипцы, "--- вздохнёт мэр, "--- кайф жгуч. &
        \( - \) &
        \( + \) &
        \( + \) &
        \({\approx}\) \\
        Нэ про натюм фюйзчыт квюальизквюэ, аэквюы жкаывола мэль ку. Ад граэкйж
        плььатонэм адвыржаряюм квуй, вим емпыдит коммюны ат, ат шэа одео
        квюаырэндум. Вёртюты ажжынтиор эффикеэнди эож нэ. &
        \( + \) &
        \( - \) &
        \({\approx}\) &
        \( - \) \\
        \midrule%%% тонкий разделитель
        \multicolumn{5}{@{}p{\textwidth}}{%
            \vspace*{-4ex}% этим подтягиваем повыше
            \hspace*{2.5em}% абзацный отступ - требование ГОСТ 2.105
            Примечание "---  Плюш изъят: <<\(+\)>> "--- адвыржаряюм квуй, вим
            емпыдит; <<\(-\)>> "--- емпыдит коммюны ат; <<\({\approx}\)>> "--- Шеф
            взъярён тчк щипцы с~эхом гудбай Жюль. Эй, жлоб! Где туз? Прячь юных
            съёмщиц в~шкаф. Экс-граф?
        }
        \\
        \bottomrule %%% нижняя линейка
    \end{tabularx}%
\end{table}

\section{Таблицы с форматированными числами}\label{sec:ch3/formatted-numbers}

В таблицах~\refs{tab:S:parse,tab:S:align} представлены примеры использования опции
форматирования чисел \texttt{S}, предоставляемой пакетом \texttt{siunitx}.

\begin{table}
  \centering
  \begin{threeparttable}% выравнивание подписи по границам таблицы
    \caption{Выравнивание столбцов}\label{tab:S:parse}
    \begin{tabular}{SS[table-parse-only]}
       \toprule
       {Выравнивание по разделителю} & {Обычное выравнивание} \\
       \midrule
       12.345                        & 12.345                 \\
       6,78                          & 6,78                   \\
       -88.8(9)                      & -88.8(9)               \\
       4.5e3                         & 4.5e3                  \\
       \bottomrule
    \end{tabular}
  \end{threeparttable}
\end{table}

\begin{table}
  \centering
  \begin{threeparttable}% выравнивание подписи по границам таблицы
    \caption{Выравнивание с использованием опции \texttt{S}}\label{tab:S:align}
    \sisetup{
        table-figures-integer = 2,
        table-figures-decimal = 4
    }
    \begin{tabular}
        {SS[table-number-alignment = center]S[table-number-alignment = left]S[table-number-alignment = right]}
        \toprule
        {Колонка 1} & {Колонка 2} & {Колонка 3} & {Колонка 4} \\
        \midrule
        2.3456      & 2.3456      & 2.3456      & 2.3456      \\
        34.2345     & 34.2345     & 34.2345     & 34.2345     \\
        56.7835     & 56.7835     & 56.7835     & 56.7835     \\
        90.473      & 90.473      & 90.473      & 90.473      \\
        \bottomrule
    \end{tabular}
  \end{threeparttable}
\end{table}

\section{Параграф "--- два}\label{sec:ch3/sect2}

Некоторый текст.

\section{Параграф с подпараграфами}\label{sec:ch3/sect3}

\subsection{Подпараграф "--- один}\label{subsec:ch3/sect3/sub1}

Некоторый текст.

\subsection{Подпараграф "--- два}\label{subsec:ch3/sect3/sub2}

Некоторый текст.

\clearpage
